<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interface on Go und die Welt</title>
    <link>https://as27.github.io/categories/interface/</link>
    <description>Recent content in Interface on Go und die Welt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de</language>
    <lastBuildDate>Sun, 04 Feb 2018 20:44:26 +0100</lastBuildDate>
    
	<atom:link href="https://as27.github.io/categories/interface/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mein io.Reader und io.Writer Interface</title>
      <link>https://as27.github.io/blog/2018/02/04/mein-io.reader-und-io.writer-interface/</link>
      <pubDate>Sun, 04 Feb 2018 20:44:26 +0100</pubDate>
      
      <guid>https://as27.github.io/blog/2018/02/04/mein-io.reader-und-io.writer-interface/</guid>
      <description>Dieser Post beschäftigt sich mit einer Möglichkeit des Refactorings, wenn externe Interfaces als Input von Funktionen verwendet werden. In dem Beispiel verwende ich den io.Reader da dieser sehr einfach aufgebaut ist und außerdem dürfte dieser Reader bereits von jedem Gopher schon öfters verwendet worden sein.
Fangen wir mal ganz einfach mit einer Funktion an:
import ( &amp;quot;io&amp;quot; ) func leseWas(r io.Reader) { // ... }  Die Funktion leseWas nimmt einen io.</description>
    </item>
    
  </channel>
</rss>