<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go und die Welt</title>
    <link>https://as27.github.io/categories/komposition/index.xml</link>
    <description>Recent content on Go und die Welt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de</language>
    <atom:link href="https://as27.github.io/categories/komposition/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Komposition für Anfänger</title>
      <link>https://as27.github.io/blog/2017/03/05/komposition-f%C3%BCr-anf%C3%A4nger/</link>
      <pubDate>Sun, 05 Mar 2017 12:25:50 +0100</pubDate>
      
      <guid>https://as27.github.io/blog/2017/03/05/komposition-f%C3%BCr-anf%C3%A4nger/</guid>
      <description>&lt;p&gt;Ein ganz einfaches Beispiel soll zeigen, was alles mit der Komposition in Go möglich ist. Nehmen wir mal folgendes Beispiel an.&lt;/p&gt;

&lt;p&gt;Es gibt einen Typ A, welches eine Methode Print() besitzt. Typ B hat in seiner Definition auf Typ A im Bauch. Wäre Go nun objekt-orientiert, würde man auch sagen, B erbt alles von A. Dadurch kann eine Instanz von B eigentlich auch alles was A kann.&lt;/p&gt;

&lt;p&gt;Diese Erkenntnis ist erstmal nichts besonderes. Auf die gleiche Weise wie B definieren wir nun Typ C. Für Typ C ist nun aber die Funktion Print() nicht so wie wir das benötigen. Also definieren wir für C die Methode einfach neu. Wenn nun eine Instanz von C die Methode Print() aufruft, dann wird unsere neue Methode dafür verwendet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type A struct {
}

func (a *A) Print() {
	fmt.Println(&amp;quot;AAAA&amp;quot;)
}

type B struct {
	A
}

type C struct {
	A
}

func (c *C) Print() {
	fmt.Println(&amp;quot;CCC&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Das ganze auch noch einmal im Playground:
&lt;a href=&#34;https://play.golang.org/p/Z0TprdJZ7_&#34;&gt;https://play.golang.org/p/Z0TprdJZ7_&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Auf den ersten Blick ist diese Logik nichts besonderes. Aber wenn man z.B. aus einem Java Umfeld kommt, dann ist es anscheinend nicht leicht, zu erkennen, wann man dieses Pattern gut anwenden kann. Insbesondere beim Testen ist diese Logik hilfreich.&lt;/p&gt;

&lt;p&gt;Im folgenden Beispiel lässt sich so ein Typ anlegen, welcher sich alle Queries merken kann und keinen Einfluss auf die DB nimmt.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MockDB struct {
	externDBPackage.DB
	Queries []string
}

func (mdb *MockDB)  Query(query string, args ...interface{}) (*Rows, error) {
	mdb.Queries = append(mdb.Queries, query)
	// Do something
	return &amp;amp;Rows{},nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ähnliche Lösungen sind möglich, wenn man z.B. vermeiden möchte, dass man in seinen Tests auf das Filesystem schreibt.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>